/**
 * @fileoverview Tests for useProductCategorization hook
 * @module features/SpeedgoOptimizer/hooks/__tests__/useProductCategorization.test
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook, waitFor, act } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactNode } from 'react';
import { useProductCategorization } from '@features/SpeedgoOptimizer/hooks/useProductCategorization';
import { submitProductCategorization } from '@features/SpeedgoOptimizer/application/submitProductCategorization';
import { createMockQueryData } from '@/lib/test-utils-query';
import type { CategoryRequestItem } from '@features/SpeedgoOptimizer/domain/schemas/CategoryRequest';

// Mock the server action
vi.mock('@features/SpeedgoOptimizer/application/submitProductCategorization', () => ({
  submitProductCategorization: vi.fn(),
}));

// Mock the client logger
vi.mock('@/lib/logger.client', () => ({
  default: {
    info: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    debug: vi.fn(),
  },
}));

// Helper to create test query client
function createTestQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        gcTime: 0,
        staleTime: 0,
      },
      mutations: {
        retry: false,
      },
    },
    logger: {
      log: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
    },
  });
}

// Helper wrapper component
function TestWrapper({ children, queryClient }: { children: ReactNode; queryClient: QueryClient }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}

/**
 * Test suite for useProductCategorization hook
 * 
 * Tests TanStack Query integration, error handling, and cache management
 * for the product categorization mutation hook.
 */
describe('useProductCategorization', () => {
  const mockProducts: CategoryRequestItem[] = createMockQueryData.categorizationRequest();
  const mockSubmitProductCategorization = vi.mocked(submitProductCategorization);

  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  /**
   * Tests successful product categorization mutation setup
   */
  it('should initialize mutation successfully', () => {
    const queryClient = createTestQueryClient();

    const { result } = renderHook(() => useProductCategorization(), {
      wrapper: ({ children }) => <TestWrapper queryClient={queryClient}>{children}</TestWrapper>,
    });

    // Initially should be idle
    expect(result.current.isPending).toBe(false);
    expect(result.current.isSuccess).toBe(false);
    expect(result.current.isError).toBe(false);
  });

  /**
   * Tests successful product categorization mutation
   */
  it('should successfully categorize products', async () => {
    const mockResponse = {
      success: true,
      data: createMockQueryData.categorizationResponse(),
    };

    mockSubmitProductCategorization.mockResolvedValue(mockResponse);

    const queryClient = createTestQueryClient();

    const { result } = renderHook(() => useProductCategorization(), {
      wrapper: ({ children }) => <TestWrapper queryClient={queryClient}>{children}</TestWrapper>,
    });

    // Initially should be idle
    expect(result.current.isPending).toBe(false);
    expect(result.current.isSuccess).toBe(false);
    expect(result.current.isError).toBe(false);

    // Use mutateAsync for better test control
    await act(async () => {
      await result.current.mutateAsync(mockProducts);
    });

    // Check final state after mutation completes
    expect(result.current.isPending).toBe(false);
    expect(result.current.isSuccess).toBe(true);
    expect(result.current.isError).toBe(false);
    expect(result.current.data).toEqual(mockResponse);
    expect(mockSubmitProductCategorization).toHaveBeenCalledWith(mockProducts);
    expect(mockSubmitProductCategorization).toHaveBeenCalledTimes(1);
  });

  /**
   * Tests error handling in product categorization
   */
  it('should handle categorization errors correctly', async () => {
    const mockError = {
      success: false,
      error: 'Validation failed: Invalid product data',
    };

    mockSubmitProductCategorization.mockResolvedValue(mockError);

    const queryClient = createTestQueryClient();

    const { result } = renderHook(() => useProductCategorization(), {
      wrapper: ({ children }) => <TestWrapper queryClient={queryClient}>{children}</TestWrapper>,
    });

    // Trigger the mutation
    result.current.mutate(mockProducts);

    // Wait for mutation to complete
    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    // Check that the hook returns the error response
    expect(result.current.data).toEqual(mockError);
    expect(result.current.isError).toBe(false); // Not a thrown error, just failed response
  });

  /**
   * Tests error handling when server action throws
   */
  it('should handle thrown errors correctly', async () => {
    const thrownError = new Error('Network error');
    mockSubmitProductCategorization.mockRejectedValue(thrownError);

    const queryClient = createTestQueryClient();

    const { result } = renderHook(() => useProductCategorization(), {
      wrapper: ({ children }) => <TestWrapper queryClient={queryClient}>{children}</TestWrapper>,
    });

    // Trigger the mutation and expect it to reject
    await act(async () => {
      try {
        await result.current.mutateAsync(mockProducts);
        throw new Error('Expected mutation to throw');
      } catch (error) {
        expect(error).toBeInstanceOf(Error);
        expect((error as Error).message).toBe('Network error');
      }
    });

    // Check error state after mutation fails
    expect(result.current.isPending).toBe(false);
    expect(result.current.isSuccess).toBe(false);
    expect(result.current.isError).toBe(true);
    expect(result.current.error).toBeInstanceOf(Error);
    expect(result.current.error?.message).toBe('Network error');
  });

  /**
   * Tests mutation reset functionality
   */
  it('should allow resetting mutation state', async () => {
    const mockResponse = {
      success: true,
      data: createMockQueryData.categorizationResponse(),
    };

    mockSubmitProductCategorization.mockResolvedValue(mockResponse);

    const queryClient = createTestQueryClient();

    const { result } = renderHook(() => useProductCategorization(), {
      wrapper: ({ children }) => <TestWrapper queryClient={queryClient}>{children}</TestWrapper>,
    });

    // Trigger and complete mutation
    await act(async () => {
      await result.current.mutateAsync(mockProducts);
    });

    // Verify mutation succeeded
    expect(result.current.isSuccess).toBe(true);
    expect(result.current.data).toEqual(mockResponse);

    // Reset mutation
    act(() => {
      result.current.reset();
    });

    // Check reset state
    expect(result.current.isPending).toBe(false);
    expect(result.current.isSuccess).toBe(false);
    expect(result.current.isError).toBe(false);
    expect(result.current.data).toBeUndefined();
    expect(result.current.error).toBeNull();
  });
});